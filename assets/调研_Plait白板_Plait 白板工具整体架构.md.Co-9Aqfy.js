import{_ as s,c as a,o as e,ae as t}from"./chunks/framework.BjG1C43O.js";const k=JSON.parse('{"title":"Plait 白板工具整体架构","description":"","frontmatter":{},"headers":[],"relativePath":"调研/Plait白板/Plait 白板工具整体架构.md","filePath":"调研/Plait白板/Plait 白板工具整体架构.md"}'),l={name:"调研/Plait白板/Plait 白板工具整体架构.md"};function n(o,i,d,p,r,h){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="plait-白板工具整体架构" tabindex="-1">Plait 白板工具整体架构 <a class="header-anchor" href="#plait-白板工具整体架构" aria-label="Permalink to &quot;Plait 白板工具整体架构&quot;">​</a></h1><p>Plait 是一个现代化的绘图框架，基于插件机制设计，可用于构建思维导图、流程图等一体化白板工具。其底层提供基础画布能力（如缩放、平移），而具体业务功能通过插件实现。总体架构可以分为以下核心模块：</p><ul><li><p><strong>数据层（Data Layer）</strong>：基于不可变数据模型（类似 Slate 的模型），使用 Immer 实现状态管理。数据以树结构形式存储，每个节点为 <code>PlaitElement</code> 类型，包含 <code>type</code>、<code>id</code>、位置坐标、样式属性以及子元素列表等。这个层负责管理白板上所有元素的数据并提供原子级别的变更（Transforms）函数，以便增删改元素。</p></li><li><p><strong>渲染层（Rendering Layer）</strong>：采用 SVG 作为绘图方案，并集成了 RoughJS 库进行手绘风格渲染。SVG 画布负责绘制所有图形元素和线条，同时可通过嵌入 <code>&lt;foreignObject&gt;</code> 来容纳富文本或 React DOM 元素，实现 HTML 内容与 SVG 绘制的并存。渲染层还封装了一些基础组件（如 <code>ReactBoard</code>/<code>AngularBoard</code>）用于将 SVG 画布挂载到页面。</p></li><li><p><strong>交互层（Interaction Layer）</strong>：核心 Board 组件监听用户事件（如 <code>mousedown</code>、<code>mousemove</code>、<code>keydown</code> 等），并将事件分发给插件。默认支持画布缩放、平移等基础交互，插件可重写这些行为来自定义业务操作。例如，在“绘制圆形”模式下，插件会拦截 <code>mousedown</code> 和 <code>mousemove</code> 来生成圆形元素。</p></li><li><p><strong>插件系统（Plugin System）</strong>：Plait 核心定义插件机制，各类功能（思维导图、流程图等）通过插件实现。在使用时，将插件函数（如 <code>withMind</code>、<code>withDraw</code>）列表传入白板组件，框架在初始化时依次调用它们注册事件处理和渲染方法。插件可以覆写数据渲染和交互行为的钩子（如 <code>drawElement</code>、<code>mousedown</code>），从而扩展功能。</p></li><li><p><strong>协作层（Collaboration）</strong>：Plait 的数据模型支持实时协作编辑，多用户可同时编辑同一白板。框架本身使用不可变状态和事件驱动更新，可与协作库（如 Yjs/CRDT）集成，实现变更广播和合并，保证多端数据一致性。核心通过 <code>PlaitBoardChangeEvent</code> 将数据变更以事件形式输出，客户端根据事件更新本地状态以同步协作。</p></li></ul><p>下图示意了 Plait 的高层架构分层关系：</p><h2 id="数据结构设计" tabindex="-1">数据结构设计 <a class="header-anchor" href="#数据结构设计" aria-label="Permalink to &quot;数据结构设计&quot;">​</a></h2><p>Plait 采用 Slate 风格的树形数据结构来描述白板内容。最顶层是一个“白板（Board）”对象，它包含一个元素列表 <code>children: PlaitElement[]</code>，每个 <code>PlaitElement</code> 可以是图形、文本或容器节点等。典型的数据模型包括：</p><ul><li><p><strong>节点（Node）</strong>：每个节点是一个对象（接口 <code>PlaitElement</code>），包含字段 <code>type</code>（元素类型，如 <code>&#39;node&#39;</code>、<code>&#39;edge&#39;</code>、<code>&#39;group&#39;</code> 等）、<code>id</code>（唯一标识）、以及对应类型的数据字段（例如节点坐标<code>x,y</code>、大小、文本内容、子节点列表等）。节点可嵌套形成层级结构，如思维导图中的分支层级。</p></li><li><p><strong>白板（Board）</strong>：对应整个画布状态，其中 <code>children</code> 是根节点列表。Board 对象还维护全局属性，如当前缩放比例、平移偏移、选中元素列表等。框架提供 <code>PlaitBoard</code> 类来封装这些状态和常用操作。</p></li><li><p><strong>连接关系（Connections）</strong>：连接通常作为特殊类型的节点存在，例如流程图中的连线可以表示为 <code>type: &#39;edge&#39;</code> 的元素，对象内可能包含起点和终点引用（如源节点 <code>sourceId</code>、目标节点 <code>targetId</code>），以及路径坐标或箭头样式等属性。插件在渲染时根据这些数据生成 SVG 路径或线段。</p></li><li><p><strong>数据更新（Transforms）</strong>：Plait 提供一组原子操作函数，用于增删改查节点。所有操作都会生成新的不可变数据状态，并通过 <code>PlaitBoardChangeEvent</code> 通知视图更新。这种以数据为中心的方式保证了渲染与交互的统一，也方便与协作同步机制结合。</p></li></ul><p><em>示例：</em> 插件定义的新元素接口，如下为圆形元素的数据结构示例。代码中定义了圆心坐标和半径：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CircleElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;circle&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  dot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>以上数据模型决定了渲染时生成的 SVG 元素（如 <code>&lt;circle&gt;</code> 或 RoughJS 绘图命令）需要读取并绘制对应属性。</p><h2 id="渲染引擎分析" tabindex="-1">渲染引擎分析 <a class="header-anchor" href="#渲染引擎分析" aria-label="Permalink to &quot;渲染引擎分析&quot;">​</a></h2><p>Plait 默认采用 <strong>SVG + RoughJS</strong> 组合进行绘制。具体特点如下：</p><ul><li><p><strong>SVG 绘制</strong>：使用 SVG 容器渲染节点和连线。选用 SVG 而非 Canvas 的原因是 SVG 对 DOM 友好，方便嵌入 HTML 内容，同时可利用 RoughJS 让线条呈现手绘风格。性能方面经测试 SVG 能够平稳地渲染 1000 级别节点而不卡顿。</p></li><li><p><strong>Rich Text 和 React DOM</strong>：为了支持富文本，Plait 在 SVG 内使用 <code>&lt;foreignObject&gt;</code> 嵌套 HTML 元素。这样可以直接在 SVG 中放入 React 管理的 DOM 节点（例如富文本编辑框）。因此元素渲染层可以同时包含原生 SVG 图形（由 RoughJS 或手写路径绘制）和 HTML DOM 组件，满足界面交互和样式扩展需求。</p></li><li><p><strong>渲染流程</strong>：PlaitBoard 负责创建基础 SVG 画布并应用当前视图变换（平移、缩放）。当数据变化或初始化时，框架遍历所有元素数据，对每个元素调用插件提供的 <code>drawElement</code> 方法生成对应的 SVG 子元素（可能是 <code>&lt;g&gt;</code> 分组或其他组件）。对于更新后的元素，调用 <code>redrawElement</code>。当元素被删除时，调用 <code>destroyElement</code> 清理 SVG 元素。</p></li><li><p><strong>React 集成</strong>：对于 React 应用，可使用官方提供的 <code>@plait/react-board</code> 组件作为白板容器。该组件内部渲染 SVG 画布并将 PlaitBoard 逻辑挂载到 React 生命周期中。同时，<code>@plait/react-text</code> 等组件负责将 Slate 文本节点渲染为 React 可编辑文本。这使得 Plait 白板可以无缝集成到 React 构建的界面中。</p></li></ul><p><em>示例：</em> Plait 中利用 <code>&lt;foreignObject&gt;</code> 嵌入 HTML 的方式，允许在 SVG 里显示富文本，例如思维节点的文字部分：</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">svg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;!-- 其他图形元素 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foreignObject</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{x} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{y} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">width</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{w} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">height</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{h}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> xmlns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://www.w3.org/1999/xhtml&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RichTextComponent</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> text</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{node.text} /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foreignObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">svg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="交互框架梳理" tabindex="-1">交互框架梳理 <a class="header-anchor" href="#交互框架梳理" aria-label="Permalink to &quot;交互框架梳理&quot;">​</a></h2><p>Plait 的交互系统由 Board 监听用户输入事件，然后通过插件机制分发和处理。以下是常用交互的实现流程：</p><ul><li><p><strong>元素拖拽</strong>：当用户在画布上选中一个元素并按下鼠标时，Board 捕获 <code>mousedown</code> 事件。插件可以判断点击目标并设置拖拽状态（例如记录起始位置）。随后在 <code>mousemove</code> 事件中，插件计算指针偏移并更新对应元素的数据坐标，实时移动元素。最终在 <code>mouseup</code> 时结束拖拽，触发数据变更事件。整个过程中，Plait 保证每次修改都是通过变换函数完成，以便触发重绘。</p></li><li><p><strong>画布平移</strong>：当用户在空白区域按住鼠标并拖动时（或按住滚轮/右键拖动），Board 切换到平移模式，调整 SVG 视图的平移偏移量。实现上通常修改顶层容器的 <code>transform</code> 或 <code>viewBox</code>，让整个画布跟随鼠标移动。</p></li><li><p><strong>缩放</strong>：Board 监听 <code>wheel</code> 滚轮事件，并结合 Ctrl 键等判断是否为缩放操作。根据滚轮方向增减缩放比例，并居中或围绕鼠标位置缩放 SVG 视图。缩放操作直接更新视图变换矩阵，不更改元素数据本身。</p></li><li><p><strong>旋转</strong>：如果元素支持旋转（如某些图形需要自由旋转），通常在选中元素时显示旋转手柄。用户拖动该手柄时，插件监听 <code>mousemove</code> 事件计算旋转角度，更新元素数据的旋转属性，从而使元素重绘时旋转。</p></li><li><p><strong>框选（多选）</strong>：当用户在空白处按下鼠标并拖出一个矩形区域时，插件会在画布上临时绘制一个半透明的选框。移动过程中实时调整选框范围；松开鼠标后，插件遍历所有元素，判断元素与选框是否相交，将满足条件的元素加入当前选中集并触发选中变更事件。</p></li><li><p><strong>快捷键</strong>：Board 在全局层监听键盘事件(<code>keydown</code>/<code>keyup</code>)，插件或应用程序可捕获常用快捷键（如 Ctrl+Z 撤销、Delete 删除、Ctrl+C/Ctrl+V 复制粘贴、Ctrl+A 全选等），并调用相应的数据变换操作。Plait 本身未定义所有快捷键，而是提供机制让上层应用或插件注册自定义快捷键处理。</p></li><li><p><strong>交互钩子</strong>：插件可以重写或扩展 Board 的事件处理函数。例如，将 <code>board.mousedown</code> 设置为自定义函数，从而在特定模式下截获点击事件。下例展示了一个“圆形绘制”模式的处理：当 <code>board.cursor===&#39;circle&#39;</code> 时，<code>mousedown</code> 事件开始记录圆心；否则调用原始的 <code>mousedown</code> 逻辑。</p></li></ul><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">board.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mousedown</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MouseEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (board.cursor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;circle&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 记录圆心坐标</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.x, event.y, board.host);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 调用默认处理</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mousedown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="插件系统设计" tabindex="-1">插件系统设计 <a class="header-anchor" href="#插件系统设计" aria-label="Permalink to &quot;插件系统设计&quot;">​</a></h2><p>Plait 插件系统设计核心参考了 Slate 编辑器的思路。其主要特性如下：</p><ul><li><p><strong>插件注册</strong>：使用时，在白板组件（如 <code>&lt;PlaitBoard&gt;</code> 或 <code>ReactBoard</code>）上通过属性传入插件列表。例如 Angular 版中：<code>&lt;plait-board [plaitPlugins]=&quot;[withMind]&quot; ...&gt;</code>。在 React 中同样通过 props 传入 <code>plugins={[withMind]}</code>。框架在初始化时依次执行这些插件函数（每个插件一般以 <code>withX</code> 命名），将插件逻辑注入 Board 中。</p></li><li><p><strong>扩展点</strong>：每个插件可提供以下扩展点：</p><ol><li><strong>数据扩展</strong>：通过提供自定义元素类型（如思维节点、连线节点等）的接口定义，让 Board 能识别新元素类型。</li><li><strong>行为钩子</strong>：重写或监听交互事件（<code>mousedown</code>、<code>mousemove</code>、<code>keydown</code> 等），实现元素创建、拖拽、编辑等行为。</li><li><strong>渲染钩子</strong>：提供 <code>drawElement</code>、<code>redrawElement</code>、<code>destroyElement</code> 等函数，用于控制元素的绘制和更新。例如，思维导图插件会为每个节点生成对应的 SVG <code>&lt;g&gt;</code> 组和文本，流程图插件会绘制矩形、箭头等。</li></ol></li><li><p><strong>生命周期钩子</strong>：当 Board 创建完成后会触发初始化事件（如 <code>plaitBoardInitialized</code>），插件或外部可以在此时获取 <code>PlaitBoard</code> 实例，进行进一步配置。在数据变更时，Board 会触发 <code>PlaitBoardChangeEvent</code>（如 Angular 中的 <code>(plaitChange)</code> 事件），插件可监听此事件执行额外逻辑。</p></li><li><p><strong>模块解耦</strong>：Plait 核心仅提供框架层支持，业务功能完全由插件实现。例如思维导图插件只专注于树形结构逻辑和布局（并不包含工具栏按钮等 UI），而上层应用再使用组件化方式为其添加工具栏等组件。这样插件层与 UI 层解耦，提高了可复用性。</p></li></ul><p>总体来说，插件通过组合模式接入 Plait 核心框架，插件函数返回值或在 Board 上注册的钩子函数会参与到事件循环和渲染循环中，实现功能拓展。</p><h2 id="协作机制分析" tabindex="-1">协作机制分析 <a class="header-anchor" href="#协作机制分析" aria-label="Permalink to &quot;协作机制分析&quot;">​</a></h2><p>Plait 原生支持多人实时协作。其数据模型基于不可变状态，每次操作都会产生新的数据快照，并通过事件机制同步到其他客户端。具体保证一致性的方式通常包括：</p><ul><li><p><strong>变更广播</strong>：任一用户在本端进行增删改操作时，会触发 <code>PlaitBoardChangeEvent</code>，该事件包含最新的整个元素树或操作记录。应用层可以监听此事件，将变化发送至服务器或其他协作者的客户端。</p></li><li><p><strong>冲突解决</strong>：因为 Plait 数据模型使用树形结构并支持原子操作（Transforms），可与 CRDT/OT 等协作库（如 Yjs、ShareDB）结合，将每一步操作序列化并在所有客户端重演。CRDT 本身能自动合并并发修改，保证最终一致。官方文档提到 Plait 数据模型“支持协作功能，多个用户可以同时编辑同一个白板，数据模型确保了数据的一致性和同步”。</p></li><li><p><strong>一致性保障</strong>：一般通过操作转换（OT）或状态合并（CRDT）技术，使得无论修改顺序如何，最终各端白板内容一致。Plait 的架构不强绑定特定网络协议，允许用户自行选择 WebSocket、WebRTC 等传输方案，并在接收变更时调用 Plait 的数据更新接口应用变更。</p></li></ul><p>总之，Plait 本身提供了协作所需的基础：可序列化的数据模型、事件驱动的更新机制和不可变状态支持；具体的网络同步和冲突解决，则需在应用层或借助第三方库完成。</p><h2 id="核心模块类-接口-函数梳理" tabindex="-1">核心模块类/接口/函数梳理 <a class="header-anchor" href="#核心模块类-接口-函数梳理" aria-label="Permalink to &quot;核心模块类/接口/函数梳理&quot;">​</a></h2><p>下面列举各模块中关键的类、接口及函数，并说明其作用和关联关系：</p><ul><li><p><strong>核心库（@plait/core）</strong></p><ul><li><code>PlaitBoard</code>：白板实例类，包含当前状态（元素树、缩放、偏移、选中集等），以及对数据的读写和交互处理方法。</li><li><code>PlaitElement</code>（接口）：所有节点数据的顶级接口，定义了基本属性如 <code>type</code>、<code>children</code> 等，用于描述图形、文本、组等各种元素的数据结构。</li><li><code>PlaitBoardChangeEvent</code>：数据变更事件对象，当 Board 数据发生更新时触发，事件中包含更新后的根元素列表，可用来同步外部状态或持久化。</li><li><strong>变换函数</strong>（Transforms）：一组函数（类似 Slate 的 <code>Transforms</code> API），用于在数据树上执行增删改操作，如添加节点、删除节点、移动节点等。所有操作都会生成新的不可变数据状态，并通过 <code>PlaitBoardChangeEvent</code> 通知视图更新。</li><li><code>BasePlugin</code>/<code>PluginRegistry</code>：插件管理相关类型，内部维护已注册插件列表，并在事件触发时依次调用插件提供的钩子方法。</li></ul></li><li><p><strong>共用库（@plait/common）</strong></p><ul><li><strong>绘制辅助</strong>：包括绘图工具类、数学计算函数（点、路径计算）、SVG 封装逻辑等。</li><li>基础交互工具：如对齐、分布等通用算法和基础插件实现，可被多种图板类型重用。</li></ul></li><li><p><strong>文本支持（@plait/text）</strong></p><ul><li>提供基于 Slate 的富文本能力，定义文本节点类型和对应编辑器插件。包含 <code>ReactText</code>（或 <code>AngularText</code>）组件，用于渲染和编辑白板中的文本内容。</li></ul></li><li><p><strong>思维导图插件（@plait/mind）</strong></p><ul><li><code>withMind</code>：插件入口函数，将思维导图功能注册到白板。</li><li><code>MindNode</code>、<code>MindLine</code> 等接口/类：用于定义思维导图节点和连线的数据结构，以及渲染时创建对应 SVG 元素。</li><li>自动布局算法：独立的布局类（如 <code>TreeLayout</code> 等），实现逻辑布局、标准布局、缩进布局等，为节点计算位置。</li></ul></li><li><p><strong>流程图插件（@plait/draw）</strong></p><ul><li><code>withDraw</code>：流程图插件入口，支持绘制矩形、圆形、箭头、贝塞尔曲线等基础图形。</li><li><code>FlowElement</code>、<code>FlowEdge</code> 等：定义流程节点和连接线的数据结构。插件提供交互逻辑，允许用户绘制和编辑各种标准流程图符号。</li></ul></li><li><p><strong>流程配置插件（@plait/flow）</strong></p><ul><li><code>withFlow</code>：用于可视化业务流程状态图的插件入口。内部定义了与业务流程相关的节点类型和交互规则。</li></ul></li><li><p><strong>布局算法库（@plait/layouts）</strong></p><ul><li>包含思维导图所需的辅助布局算法类（如 <code>TreeLayout</code>、<code>IndentedLayout</code> 等），供 <code>@plait/mind</code> 插件使用，实现节点自动分布。</li></ul></li><li><p><strong>React 集成（@plait/react-board、@plait/react-text）</strong></p><ul><li><code>ReactBoard</code>：React 组件，封装了 PlaitBoard 对象和 SVG 画布，将 Plait 集成到 React 应用。它接受插件列表和初始值等属性，并在内部创建 <code>PlaitBoard</code> 实例。</li><li><code>ReactText</code>：用于渲染文本元素的 React 组件，依赖 Slate，在 SVG 内部插入可编辑文本。</li></ul></li></ul><p>以上类/接口相互配合：核心库负责数据管理和事件分发，共用库提供绘制工具，插件库定义具体的节点类型和交互逻辑，React/Angular 组件则负责在对应框架中承载白板视图。通过组合这些模块，开发者可以快速构建丰富的白板功能并在此基础上二次开发扩展。</p><h2 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h2><ul><li><a href="https://github.com/plait-board/x-plait" target="_blank" rel="noreferrer">https://github.com/plait-board/x-plait</a></li><li><a href="https://pubuzhixing.medium.com/0-1-create-a-modern-drawing-framework-9b3622466213" target="_blank" rel="noreferrer">https://pubuzhixing.medium.com/0-1-create-a-modern-drawing-framework-9b3622466213</a></li></ul>`,33)]))}const g=s(l,[["render",n]]);export{k as __pageData,g as default};
